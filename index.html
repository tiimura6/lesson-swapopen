<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>改・授業の交換先をすぐに見つける君[2025年11月-12月]©Takahiro Iimura</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; margin: 20px; }
    h1 { font-size: 1.3rem; margin-bottom: 1rem; }
    h2 { font-size: 1.1rem; margin-top: 1.4rem; }
    p, label { display:block; margin-top:0.6rem; }
    select,input { padding:4px; }
    table { border-collapse:collapse; margin-top:0.6rem; width:100%; max-width:1200px; }
    th,td { border:1px solid #ccc; padding:6px 8px; font-size:0.9rem; text-align:left; vertical-align: top; }
    th { background:#f0f0f0; font-size:1.1rem; }
    tbody tr:hover { background:#f5f5f5; }

    .training-conflict { color: red; font-weight: 700; }
    .self-training     { color: purple; font-weight: 700; }
    .parttime-row      { color: blue; font-weight: 700; }

    .muted { color:#666; font-size:0.9rem; }
    .nowrap { white-space: nowrap; }
    .notice { font-size:0.9rem; color:#444; }
    .hidden { display:none; }
    .btn { padding:8px 12px; border:1px solid #999; border-radius:6px; background:#f5f5f5; cursor:pointer; }
    .inline { display:inline-block; margin-right:10px; }
    .hr { margin: 24px 0; border: none; border-top: 1px dotted #ddd; }
    .select-with-search { display:inline-flex; align-items:center; gap:6px; }
    .search-input { width: 160px; }

    .info-warning { color: orange; }
  </style>
</head>
<body>
  <h1>改・授業の交換先をすぐに見つける君[2025年11月-12月]©Takahiro Iimura</h1>

  <!-- 教員A（検索内包） -->
  <div class="inline select-with-search">
    <label>教員A:
      <select id="teacherSelectA" disabled>
        <option value="">データ読み込み待機中</option>
      </select>
      <input id="teacherSearchA" class="search-input" type="text" placeholder="名前で絞り込み" aria-label="教員A検索" />
    </label>
  </div>

  <!-- 教員B：選択されたら合同扱い。候補はAの合同者のみ -->
  <div id="teacherBWrap" class="inline">
    <label>教員B（合同授業の場合）:
      <select id="teacherSelectB" disabled>
        <option value="">教員Bを選択</option>
      </select>
    </label>
  </div>

  <!-- 教員C：3人合同対応。B選択後に「残りの教員」が自動候補 -->
  <div id="teacherCWrap" class="inline">
    <label>教員C（合同授業の場合）:
      <select id="teacherSelectC" disabled>
        <option value="">教員Cを選択</option>
      </select>
    </label>
  </div>

  <label>交換したい授業:
    <select id="lessonSelect" disabled>
      <option value="">教員A（合同授業の場合B・C）を選んでください</option>
    </select>
  </label>

  <div id="results1to1" style="margin-top:1.2rem;"></div>
  <div id="results3way"  style="margin-top:1.2rem;"></div>

  <hr class="hr" />

  <!-- ===== CSV設定 ===== -->
  <button id="toggleCsvBtn" type="button" class="btn" aria-controls="csvPanel" aria-expanded="false">
    CSV設定を表示
  </button>

  <div id="csvPanel" class="hidden">
    <p class="notice"><strong>アップロードで上書き可能</strong></p>

    <p><strong>① 研修CSV（任意）</strong></p>
    <label>
      研修CSVを読み込む:<br>
      <input type="file" id="fileTrainings" accept=".csv" />
    </label>

    <p><strong>② 高校CSV（任意）</strong></p>
    <label>高校の授業CSVを読み込む:
      <input type="file" id="fileLessonsHS" accept=".csv" />
      <br><span class="muted">読み込み時に既存の高校データを更新</span>
    </label>

    <p><strong>③ 中学CSV（任意）</strong></p>
    <label>中学の授業CSVを読み込む:
      <input type="file" id="fileLessonsJH" accept=".csv" />
      <br><span class="muted">読み込み時に既存の中学データを更新</span>
    </label>
  </div>

  <script>
    // ===== CSV設定トグル =====
    const toggleBtn = document.getElementById('toggleCsvBtn');
    const csvPanel  = document.getElementById('csvPanel');
    toggleBtn.addEventListener('click', () => {
      const nowHidden = csvPanel.classList.toggle('hidden');
      toggleBtn.setAttribute('aria-expanded', String(!nowHidden));
      toggleBtn.textContent = nowHidden ? 'CSV設定を表示' : 'CSV設定を非表示';
    });

    // ===== 埋め込みサンプルCSV =====
    const EMBEDDED_TRAININGS_CSV = `teacher,day,slot,detail,day1,slot1,detail1,day2,slot2,detail2,day3,slot3,detail3,day4,slot4,detail4,day5,slot5,detail5,day6,slot6,detail6

`;

    const EMBEDDED_LESSONS_HS_CSV = `teacher,grade,class,course,day,period,subject,group

`;

    const EMBEDDED_LESSONS_JH_CSV = `teacher,grade,class,course,day,period,subject,group

`;

    // ===== 定数・共通変数 =====
    const DAY_MAP_IN = {
      "mon":"Mon","monday":"Mon","月":"Mon",
      "tue":"Tue","tuesday":"Tue","火":"Tue",
      "wed":"Wed","wednesday":"Wed","水":"Wed",
      "thu":"Thu","thursday":"Thu","木":"Thu",
      "fri":"Fri","friday":"Fri","金":"Fri",
      "sat":"Sat","saturday":"Sat","土":"Sat"
    };
    const DAY_JA_OUT = {Mon:"月",Tue:"火",Wed:"水",Thu:"木",Fri:"金",Sat:"土"};
    const DAY_ORDER  = {Mon:1,Tue:2,Wed:3,Thu:4,Fri:5,Sat:6};
    const collatorJA = new Intl.Collator('ja');

    let lessonsHS = [];
    let lessonsJH = [];
    let lessons   = [];

    // 研修・会議イベント: key = "teacher|day|period" -> Set(labels)
    let trainingEventsMap = new Map();
    // 研修CSVに一度でも名前が出た教員（常勤判定用）
    let trainingTeachers  = new Set();

    // インデックス群
    let signatureIndex = new Map();   // signatureKey -> { lesson, teachers:Set }
    let unitIndex      = new Map();   // unitKeyForTeacherSlot -> lesson[]
    let scheduleState  = new Map();   // teacher -> day -> Set(period)

    const fileLessonsHS   = document.getElementById('fileLessonsHS');
    const fileLessonsJH   = document.getElementById('fileLessonsJH');
    const fileTrainings   = document.getElementById('fileTrainings');
    const teacherSelectA  = document.getElementById('teacherSelectA');
    const teacherSelectB  = document.getElementById('teacherSelectB');
    const teacherSelectC  = document.getElementById('teacherSelectC');
    const teacherSearchA  = document.getElementById('teacherSearchA');
    const lessonSelect    = document.getElementById('lessonSelect');
    const results1to1Div  = document.getElementById('results1to1');
    const results3wayDiv  = document.getElementById('results3way');

    // ===== 汎用パーサ =====
    function parseCSV(t){
      return t.replace(/^\uFEFF/,'')
              .trim()
              .split(/\r?\n/)
              .map(l => l.split(',').map(s => s.trim()));
    }
    function normalizeDay(d){
      if(!d) return "";
      const k = String(d).toLowerCase();
      return DAY_MAP_IN[k] || d;
    }
    function parseDigit(s){
      if(!s && s!==0) return NaN;
      const m = String(s).match(/\d+/);
      return m ? parseInt(m[0],10) : NaN;
    }
    function parseGrade(g){
      const n = parseDigit(g);
      return [1,2,3].includes(n) ? n : NaN;
    }
    function parseClass(c){ return parseDigit(c); }
    function parsePeriod(p){
      const n = parseDigit(p);
      return (n>=1 && n<=7) ? n : NaN;
    }
    function normalizeCourse(c){
      if(!c) return "";
      const raw = String(c).trim();
      const low = raw.toLowerCase();
      if (["文","文系","humanities","arts","h"].includes(low)) return "文";
      if (["理","理系","science","sci","s"].includes(low))      return "理";
      return raw;
    }

    // slot 値から対象 period 配列 ("1-4" / "5-7" / 具体的な限数) を返す
    function getPeriodsForSlotValue(slotVal){
      if(!slotVal) return [];
      const s = String(slotVal).trim();
      if (s === "1-4" || s === "1〜4" || s === "1-4限" || s === "1〜4限") {
        return [1,2,3,4];
      }
      if (s === "5-7" || s === "5〜7" || s === "5-7限" || s === "5〜7限") {
        return [5,6,7];
      }
      const n = parsePeriod(s);
      return Number.isNaN(n) ? [] : [n];
    }

    // ===== 研修・会議関連 =====
    function eventKey(teacher, day, period){
      return `${teacher}|${day}|${period}`;
    }

    function addTrainingEvent(teacher, day, period, label){
      if(!teacher || !day || Number.isNaN(period)) return;
      if(!["Mon","Tue","Wed","Thu","Fri","Sat"].includes(day)) return;
      const key = eventKey(teacher, day, period);
      if(!trainingEventsMap.has(key)) trainingEventsMap.set(key, new Set());
      if(label && label.trim()) trainingEventsMap.get(key).add(label.trim());
    }

    function isParttimeTeacher(t){
      if(!t) return false;
      return !trainingTeachers.has(t);
    }

    function hasAnyEvent(teacher, day, period){
      if(!teacher || !day || !period) return false;
      const key = eventKey(teacher, day, period);
      return trainingEventsMap.has(key);
    }

    function getTrainingDetailLabel(teacher, day, period){
      if(!teacher || !day || !period) return "";
      const key = eventKey(teacher, day, period);
      const set = trainingEventsMap.get(key);
      if(!set || !set.size) return "";
      const labels = Array.from(set);
      return `${teacher}: ${labels.join("、")}`;
    }

    // 研修CSV 読み込み（slot=1-4 / 5-7 対応）
    function loadTrainingsFromText(text){
      const d = parseCSV(text);
      trainingEventsMap = new Map();
      trainingTeachers  = new Set();

      if(d.length < 2) return;

      const h = d[0].map(x => x.toLowerCase());
      const iT    = h.indexOf('teacher');
      const iD0   = h.indexOf('day');
      const iS0   = h.indexOf('slot');
      const iDet0 = h.indexOf('detail');

      const iD1  = h.indexOf('day1');
      const iS1  = h.indexOf('slot1');
      const iDe1 = h.indexOf('detail1');
      const iD2  = h.indexOf('day2');
      const iS2  = h.indexOf('slot2');
      const iDe2 = h.indexOf('detail2');
      const iD3  = h.indexOf('day3');
      const iS3  = h.indexOf('slot3');
      const iDe3 = h.indexOf('detail3');
      const iD4  = h.indexOf('day4');
      const iS4  = h.indexOf('slot4');
      const iDe4 = h.indexOf('detail4');
      const iD5  = h.indexOf('day5');
      const iS5  = h.indexOf('slot5');
      const iDe5 = h.indexOf('detail5');
      const iD6  = h.indexOf('day6');
      const iS6  = h.indexOf('slot6');
      const iDe6 = h.indexOf('detail6');

      function extractExtra(r, iD, iS, iDet){
        if(iD < 0 || iS < 0) return null;
        const day     = normalizeDay(r[iD]);
        const periods = getPeriodsForSlotValue(r[iS]);
        const detail  = (iDet >= 0 && r[iDet]) ? String(r[iDet]).trim() : "";
        if(!day || !periods.length) return null;
        if(!["Mon","Tue","Wed","Thu","Fri","Sat"].includes(day)) return null;
        return { day, periods, detail };
      }

      d.slice(1).forEach(r => {
        const teacher = r[iT];
        if (!teacher) return;

        trainingTeachers.add(teacher);

        const baseDay    = normalizeDay(r[iD0]);
        const baseSlots  = getPeriodsForSlotValue(r[iS0]);
        const baseDetail = (iDet0 >= 0 && r[iDet0]) ? String(r[iDet0]).trim() : "";

        const hasBase = baseDay &&
                        baseSlots.length>0 &&
                        ["Mon","Tue","Wed","Thu","Fri","Sat"].includes(baseDay);

        if(hasBase){
          baseSlots.forEach(p => {
            addTrainingEvent(teacher, baseDay, p, baseDetail || "研修");
          });
        }

        const e1 = extractExtra(r, iD1, iS1, iDe1); if(e1) e1.periods.forEach(p=>addTrainingEvent(teacher, e1.day, p, e1.detail || "会議"));
        const e2 = extractExtra(r, iD2, iS2, iDe2); if(e2) e2.periods.forEach(p=>addTrainingEvent(teacher, e2.day, p, e2.detail || "会議"));
        const e3 = extractExtra(r, iD3, iS3, iDe3); if(e3) e3.periods.forEach(p=>addTrainingEvent(teacher, e3.day, p, e3.detail || "会議"));
        const e4 = extractExtra(r, iD4, iS4, iDe4); if(e4) e4.periods.forEach(p=>addTrainingEvent(teacher, e4.day, p, e4.detail || "会議"));
        const e5 = extractExtra(r, iD5, iS5, iDe5); if(e5) e5.periods.forEach(p=>addTrainingEvent(teacher, e5.day, p, e5.detail || "会議"));
        const e6 = extractExtra(r, iD6, iS6, iDe6); if(e6) e6.periods.forEach(p=>addTrainingEvent(teacher, e6.day, p, e6.detail || "会議"));
      });
    }

    // ===== 授業データ関連 =====
    function parseLessonsCore(text){
      const d = parseCSV(text);
      if(d.length<2) return [];
      const h = d[0].map(x => x.toLowerCase());
      const iT     = h.indexOf('teacher');
      const iG     = h.indexOf('grade');
      const iC     = h.indexOf('class');
      const iCourse= h.indexOf('course');
      const iD     = h.indexOf('day');
      const iP     = h.indexOf('period');
      const iS     = h.indexOf('subject');
      const iGrp   = h.indexOf('group');

      return d.slice(1).map(r => ({
        teacher : r[iT],
        grade   : parseGrade(r[iG]),
        class   : parseClass(r[iC]),
        course  : normalizeCourse(r[iCourse]),
        day     : normalizeDay(r[iD]),
        period  : parsePeriod(r[iP]),
        subject : r[iS],
        group   : (iGrp>=0 ? (r[iGrp] || "") : "")
      })).filter(l =>
        l.teacher &&
        [1,2,3].includes(l.grade) &&
        ["Mon","Tue","Wed","Thu","Fri","Sat"].includes(l.day) &&
        !Number.isNaN(l.period)
      );
    }

    function loadLessonsFromTextHS(text){
      lessonsHS = parseLessonsCore(text).map(l => ({ ...l, school:"HS" }));
      rebuildLessons();
    }
    function loadLessonsFromTextJH(text){
      lessonsJH = parseLessonsCore(text).map(l => ({ ...l, school:"JH" }));
      rebuildLessons();
    }

    // ===== キー関数 =====
    function unitKeyForTeacherSlot(l){
      return `${l.school||""}|${l.teacher}|${l.day}|${l.period}|${l.subject||""}`;
    }

    function signatureKey(l){
      return `${l.school||""}|${l.day}|${l.period}|${l.grade}|${l.class}|${(l.course||"")}|${l.subject||""}`;
    }

    // ===== インデックス利用関数 =====
    function getUnitLessons(l){
      const key = unitKeyForTeacherSlot(l);
      return unitIndex.get(key) || [];
    }

    function getAllTeachersForLesson(l){
      const entry = signatureIndex.get(signatureKey(l));
      if(!entry){
        return l.teacher ? [l.teacher] : [];
      }
      return Array.from(entry.teachers).sort((a,b)=>collatorJA.compare(a,b));
    }

    function getCoteachersOfTeacher(name){
      const res = new Set();
      signatureIndex.forEach(entry => {
        if(entry.teachers.has(name) && entry.teachers.size>1){
          entry.teachers.forEach(t => {
            if(t!==name) res.add(t);
          });
        }
      });
      return Array.from(res);
    }

    // 学校ラベル
    function getSchoolLabel(l){
      if(l.school === "HS") return "【高】";
      if(l.school === "JH") return "【中】";
      return "";
    }

    // 授業名表示： 【高】月１限3年1組（文理） コミ英II / 英表I
    function renderLessonTextBase(l){
      const unit = getUnitLessons(l);
      if (!unit.length) return "";

      const base    = unit[0];
      const school  = getSchoolLabel(base);
      const dayJa   = DAY_JA_OUT[base.day] || base.day;
      const period  = base.period;
      const grade   = base.grade;

      // クラス＋コース（文 / 理 / 文理）
      const byClass = new Map(); // classNo -> Set(course)
      unit.forEach(x => {
        if (Number.isNaN(x.class)) return;
        const key = x.class;
        if (!byClass.has(key)) byClass.set(key, new Set());
        if (x.course) byClass.get(key).add(x.course);
      });

      const classNos = Array.from(byClass.keys()).sort((a,b)=>a-b);
      const labels = classNos.map(cls => {
        const set = byClass.get(cls);
        let suffix = "";
        if (grade >= 2 && base.school === "HS") {
          const hasBun = set.has("文");
          const hasRi  = set.has("理");
          if (hasBun && hasRi) {
            suffix = "文理";
          } else if (hasBun) {
            suffix = "文";
          } else if (hasRi) {
            suffix = "理";
          }
        }
        return suffix ? `${cls}${suffix}` : String(cls);
      });

      const classStr = classNos.length ? `${grade}年${labels.join("・")}組` : `${grade}年`;

      // （文 / 理 / 文理）を学年・組の直後にまとめて表示
      let coursePart = "";
      if (grade >= 2 && base.school === "HS") {
        let hasBun = false;
        let hasRi  = false;
        unit.forEach(x => {
          if (x.grade === grade && !Number.isNaN(x.class)) {
            if (x.course === "文") hasBun = true;
            else if (x.course === "理") hasRi = true;
          }
        });
        if (hasBun && hasRi) coursePart = "（文理）";
        else if (hasBun)     coursePart = "（文）";
        else if (hasRi)      coursePart = "（理）";
      }

      // ここで「文理組」「文組」「理組」を「組」に置き換え
      let baseText = `${school}${dayJa}${period}限${classStr}${coursePart}`;
      baseText = baseText
        .replace(/文理組/g, "組")
        .replace(/文組/g,   "組")
        .replace(/理組/g,   "組");

      // 科目名（unit内のsubjectをCSV順で重複排除して「 / 」で連結）
      const subjectList = [];
      unit.forEach(x => {
        const s = (x.subject || "").trim();
        if (!s) return;
        if (!subjectList.includes(s)) subjectList.push(s);
      });
      const subjectPart = subjectList.length ? " " + subjectList.join(" / ") : "";

      return `${baseText}${subjectPart}`;
    }

    // プルダウン用
    function renderLessonTextForDropdown(l){
      return renderLessonTextBase(l);
    }

    // 結果表用（「情報」にだけ注意文）
    function renderLessonTextForResult(l){
      const unit = getUnitLessons(l);
      if (!unit.length) return renderLessonTextBase(l);

      const baseText = renderLessonTextBase(l);
      const subject  = unit[0].subject;

      if (subject === "情報") {
        return `${baseText}<span class="info-warning">（※情報教室の重複に注意）</span>`;
      }
      return baseText;
    }

    // 合併授業判定
    function isJointLessonForTeacher(target){
      const unit = getUnitLessons(target);
      if (!unit.length) return false;
      return unit.length > 1;
    }

    function renderMyLessonText(l){
      let text = renderLessonTextForResult(l);
      if (isJointLessonForTeacher(l)) {
        text += "（合同）";
      }
      return text;
    }

    // 優先度（3者ローテ用）
    function getPriority(target, me){
      const joint     = isJointLessonForTeacher(target);
      const hasEvent  = hasAnyEvent(target.teacher, me.day, me.period);
      const parttime  = isParttimeTeacher(target.teacher);
      if(!joint && !hasEvent && !parttime) return 3;
      if(joint && !hasEvent && !parttime)  return 2;
      if(hasEvent && !parttime)            return 1;
      return 0;
    }

    // 同じ学校・同じ学年・同じ組・（高2以上は同じコース）
    function sameClassAndCourse(a,b){
      return a.school === b.school &&
             a.grade  === b.grade  &&
             a.class  === b.class  &&
             (a.grade < 2 || (a.course||"") === (b.course||""));
    }

    // Aが文理ユニットか
    function isBunriUnitForLesson(l){
      const unit = getUnitLessons(l);
      if (!unit.length) return false;
      if (l.grade < 2 || l.school !== "HS") return false;

      const sameClassLessons = unit.filter(x =>
        x.grade === l.grade &&
        x.class === l.class
      );
      if (!sameClassLessons.length) return false;

      let hasBun = false;
      let hasRi  = false;
      sameClassLessons.forEach(x => {
        if (x.course === "文") hasBun = true;
        else if (x.course === "理") hasRi = true;
      });
      return hasBun && hasRi;
    }

    // ===== 授業リスト再構築 & インデックス =====
    function rebuildLessons(){
      lessons = [...lessonsHS, ...lessonsJH];

      signatureIndex = new Map();
      unitIndex      = new Map();
      scheduleState  = new Map();

      lessons.forEach(l => {
        // signatureIndex
        const sKey = signatureKey(l);
        let sEntry = signatureIndex.get(sKey);
        if(!sEntry){
          sEntry = { lesson: l, teachers: new Set() };
          signatureIndex.set(sKey, sEntry);
        }
        if(l.teacher) sEntry.teachers.add(l.teacher);

        // unitIndex
        const uKey = unitKeyForTeacherSlot(l);
        let uArr = unitIndex.get(uKey);
        if(!uArr){
          uArr = [];
          unitIndex.set(uKey, uArr);
        }
        uArr.push(l);

        // scheduleState
        if(!scheduleState.has(l.teacher)) scheduleState.set(l.teacher, new Map());
        const dayMap = scheduleState.get(l.teacher);
        if(!dayMap.has(l.day)) dayMap.set(l.day, new Set());
        dayMap.get(l.day).add(l.period);
      });

      const uniqTeachers = [...new Set(lessons.map(l=>l.teacher))].filter(Boolean);
      const sorted = uniqTeachers.sort((a,b)=>{
        const A = isParttimeTeacher(a), B = isParttimeTeacher(b);
        if(A && !B) return 1;
        if(!A && B) return -1;
        return collatorJA.compare(a,b);
      });
      enableTeacherSelects(sorted);
    }

    // ===== ファイル読み込み =====
    function loadTrainings(file){
      const r = new FileReader();
      r.onload = e => {
        loadTrainingsFromText(e.target.result);
        clearTables();
        rebuildLessons();
      };
      r.onerror = () => { alert('CSVの読み込みに失敗しました'); };
      r.readAsText(file,'UTF-8');
    }
    function loadLessonsHS(file){
      const r = new FileReader();
      r.onload = e => {
        loadLessonsFromTextHS(e.target.result);
        clearTables();
      };
      r.onerror = () => { alert('CSVの読み込みに失敗しました'); };
      r.readAsText(file,'UTF-8');
    }
    function loadLessonsJH(file){
      const r = new FileReader();
      r.onload = e => {
        loadLessonsFromTextJH(e.target.result);
        clearTables();
      };
      r.onerror = () => { alert('CSVの読み込みに失敗しました'); };
      r.readAsText(file,'UTF-8');
    }

    fileTrainings?.addEventListener('change',e=>{
      if(e.target.files[0]) loadTrainings(e.target.files[0]);
    });
    fileLessonsHS?.addEventListener('change',e=>{
      if(e.target.files[0]) loadLessonsHS(e.target.files[0]);
    });
    fileLessonsJH?.addEventListener('change',e=>{
      if(e.target.files[0]) loadLessonsJH(e.target.files[0]);
    });

    // ===== 教員選択UI =====
    function filterAndPopulateTeacherOptions(sel, list, term='', placeholder='教員を選択', keepValue=''){
      sel.innerHTML = `<option value="">${placeholder}</option>`;
      const t = term.trim();
      const filtered = t ? list.filter(name => name.includes(t)) : list.slice();
      filtered.forEach((name, idx)=>{
        const op = document.createElement('option');
        op.value = name;
        op.textContent = `${String(idx+1).padStart(2,'0')}. ${name}`;
        sel.appendChild(op);
      });
      sel.disabled = (filtered.length===0);
      if (keepValue && filtered.includes(keepValue)) sel.value = keepValue;
    }
    function populateTeacherOptions(sel, list, placeholder='教員を選択'){
      filterAndPopulateTeacherOptions(sel, list, '', placeholder);
    }

    let allTeacherList = [];
    function enableTeacherSelects(list){
      allTeacherList = list.slice();
      populateTeacherOptions(teacherSelectA, list, '教員Aを選択');
      populateTeacherOptions(teacherSelectB, [],  '教員Bを選択');
      populateTeacherOptions(teacherSelectC, [],  '教員Cを選択');
      teacherSearchA.value = '';
      lessonSelect.disabled = true;
      lessonSelect.innerHTML = '<option value="">教員A（合同授業の場合B・C）を選んでください</option>';
      clearTables();
    }

    function refreshTeacherBCOptions(){
      const a = teacherSelectA.value;
      if(!a){
        populateTeacherOptions(teacherSelectB, [], '教員Bを選択');
        populateTeacherOptions(teacherSelectC, [], '教員Cを選択');
        return;
      }
      const co = getCoteachersOfTeacher(a).sort((x,y)=>collatorJA.compare(x,y));
      populateTeacherOptions(teacherSelectB, co, '教員Bを選択');
      populateTeacherOptions(teacherSelectC, [], '教員Cを選択');
    }

    // 検索デバウンス
    let teacherSearchTimer = null;
    function handleTeacherSearchInput(){
      const term = teacherSearchA.value.trim();
      const prev = teacherSelectA.value;

      filterAndPopulateTeacherOptions(
        teacherSelectA,
        allTeacherList,
        term,
        '教員Aを選択',
        prev
      );

      if (term) {
        const exact = allTeacherList.find(name => name === term);
        if (exact) {
          teacherSelectA.value = exact;
        } else if (!teacherSelectA.value && teacherSelectA.options.length === 2) {
          teacherSelectA.selectedIndex = 1;
        }
      }

      if (teacherSelectA.value) {
        refreshTeacherBCOptions();
      } else {
        populateTeacherOptions(teacherSelectB, [], '教員Bを選択');
        populateTeacherOptions(teacherSelectC, [], '教員Cを選択');
      }
      updateLessonChoices();
    }

    teacherSearchA.addEventListener('input', ()=>{
      clearTimeout(teacherSearchTimer);
      teacherSearchTimer = setTimeout(handleTeacherSearchInput, 250);
    });

    teacherSelectA.addEventListener('change', ()=>{
      refreshTeacherBCOptions();
      updateLessonChoices();
    });

    function getThirdTeachersForAandB(a,b){
      const set = new Set();
      signatureIndex.forEach(entry=>{
        if(entry.teachers.has(a) && entry.teachers.has(b) && entry.teachers.size>=3){
          entry.teachers.forEach(t=>{
            if(t!==a && t!==b) set.add(t);
          });
        }
      });
      return Array.from(set).sort((x,y)=>collatorJA.compare(x,y));
    }

    teacherSelectB.addEventListener('change', () => {
      const a = teacherSelectA.value;
      const b = teacherSelectB.value;

      if (!a || !b) {
        populateTeacherOptions(teacherSelectC, [], '教員Cを選択');
        updateLessonChoices();
        return;
      }

      const remaining = getThirdTeachersForAandB(a,b);
      populateTeacherOptions(teacherSelectC, remaining, '教員Cを選択');

      if (remaining.length === 1) {
        teacherSelectC.value = remaining[0];
      }

      updateLessonChoices();
    });

    teacherSelectC.addEventListener('change', updateLessonChoices);

    function clearTables(){
      results1to1Div.textContent = "";
      results3wayDiv.textContent = "";
    }

    function teacherHasSlot(t,d,p){
      const dayMap = scheduleState.get(t);
      if(!dayMap) return false;
      const set = dayMap.get(d);
      if(!set) return false;
      return set.has(p);
    }

    function teacherHasSlotMany(names,d,p){
      return names.some(n => teacherHasSlot(n,d,p));
    }

    function formatSlot(day,period){
      const d = DAY_JA_OUT[day] || day;
      return `${d}${period}限`;
    }

    // ===== 状態クローン & オペレーション検証 =====
    function cloneScheduleState(state){
      const copy = new Map();
      for (const [t, dayMap] of state.entries()) {
        const newDayMap = new Map();
        for (const [d, periods] of dayMap.entries()) {
          newDayMap.set(d, new Set(periods));
        }
        copy.set(t, newDayMap);
      }
      return copy;
    }

    function validateOperations(operations, baseState, options={}){
      const { allowTraining = false } = options;
      const state = cloneScheduleState(baseState);

      for(const op of operations){
        const { teacher, dayFrom, periodFrom, dayTo, periodTo } = op;
        if(!teacher || !dayFrom || !dayTo || !periodFrom || !periodTo) return false;

        const dayMap = state.get(teacher);
        if(!dayMap) return false;
        const fromSet = dayMap.get(dayFrom);
        if(!fromSet || !fromSet.has(periodFrom)) return false;

        const toSet = dayMap.get(dayTo) || new Set();
        if(toSet.has(periodTo)) return false;

        if(!allowTraining && hasAnyEvent(teacher, dayTo, periodTo)) return false;

        fromSet.delete(periodFrom);
        dayMap.set(dayFrom, fromSet);
        toSet.add(periodTo);
        dayMap.set(dayTo, toSet);
        state.set(teacher, dayMap);
      }

      return true;
    }

    function buildRotate3OperationsPattern(lA, lB, lC, groupA, groupB, groupC, patternId){
      const ops = [];
      if (patternId === 1) {
        groupA.forEach(t=>{
          ops.push({ teacher:t, dayFrom:lA.day, periodFrom:lA.period, dayTo:lB.day, periodTo:lB.period });
        });
        groupB.forEach(t=>{
          ops.push({ teacher:t, dayFrom:lB.day, periodFrom:lB.period, dayTo:lC.day, periodTo:lC.period });
        });
        groupC.forEach(t=>{
          ops.push({ teacher:t, dayFrom:lC.day, periodFrom:lC.period, dayTo:lA.day, periodTo:lA.period });
        });
      } else if (patternId === 2) {
        groupA.forEach(t=>{
          ops.push({ teacher:t, dayFrom:lA.day, periodFrom:lA.period, dayTo:lC.day, periodTo:lC.period });
        });
        groupC.forEach(t=>{
          ops.push({ teacher:t, dayFrom:lC.day, periodFrom:lC.period, dayTo:lB.day, periodTo:lB.period });
        });
        groupB.forEach(t=>{
          ops.push({ teacher:t, dayFrom:lB.day, periodFrom:lB.period, dayTo:lA.day, periodTo:lA.period });
        });
      }
      return ops;
    }

    // ===== 授業プルダウン更新 =====
    function updateLessonChoices(){
      clearTables();
      const a = teacherSelectA.value;
      const b = teacherSelectB.value;
      const c = teacherSelectC.value;

      const namesSelf = [];
      if(a) namesSelf.push(a);
      if(b) namesSelf.push(b);
      if(c) namesSelf.push(c);
      const useJoint = namesSelf.length > 1;

      if(!a){
        lessonSelect.disabled = true;
        lessonSelect.innerHTML =
          '<option value="">教員A（合同授業の場合B・C）を選んでください</option>';
        return;
      }

      let list = [];

      if(!useJoint){
        const all = lessons.filter(l => {
          if (l.teacher !== a) return false;
          const teachers = getAllTeachersForLesson(l);
          return teachers.length === 1 && teachers[0] === a;
        });
        const unitSeen = new Set();
        all.forEach(l=>{
          const key = unitKeyForTeacherSlot(l);
          if(unitSeen.has(key)) return;
          unitSeen.add(key);
          list.push(l);
        });
      } else {
        const jointSet = new Set();
        signatureIndex.forEach((entry, key)=>{
          const teachersArr = Array.from(entry.teachers);
          if(namesSelf.every(tName => teachersArr.includes(tName))){
            jointSet.add(key);
          }
        });

        const all = lessons.filter(l => l.teacher===a && jointSet.has(signatureKey(l)));
        const unitSeen = new Set();
        all.forEach(l=>{
          const key = unitKeyForTeacherSlot(l);
          if(unitSeen.has(key)) return;
          unitSeen.add(key);
          list.push(l);
        });
      }

      lessonSelect.innerHTML = '<option value="">授業を選択</option>';
      list.forEach(l=>{
        const op = document.createElement('option');
        op.value = unitKeyForTeacherSlot(l);
        op.textContent = renderLessonTextForDropdown(l);
        lessonSelect.appendChild(op);
      });
      lessonSelect.disabled = (list.length === 0);
    }

    // ===== 1対1・二段階・三者・文理特別 =====
    lessonSelect.addEventListener('change', e=>{
      results1to1Div.innerHTML = "";
      results3wayDiv.innerHTML = "";

      const unitKey = e.target.value;
      if(!unitKey) return;

      const myUnitLessons = unitIndex.get(unitKey) || [];
      if(!myUnitLessons.length) return;

      const me      = myUnitLessons[0];
      const a = teacherSelectA.value;
      const b = teacherSelectB.value;
      const c = teacherSelectC.value;

      const namesSelf = [];
      if(a) namesSelf.push(a);
      if(b) namesSelf.push(b);
      if(c) namesSelf.push(c);
      const useJoint = namesSelf.length > 1;

      const myDay   = me.day;
      const myPeriod= me.period;

      const myClassKeys   = new Set(myUnitLessons.map(l => `${l.grade}-${l.class}`));
      const myMergeCount  = myClassKeys.size;

      const poolBase = lessons.filter(o => {
        const otherUnitLessons  = getUnitLessons(o);
        const otherClassKeysArr = otherUnitLessons.map(l => `${l.grade}-${l.class}`);
        const otherMergeCount   = otherClassKeysArr.length;

        if (myMergeCount > 1) {
          if (otherMergeCount !== myMergeCount) return false;
          const otherSet = new Set(otherClassKeysArr);
          for (const k of myClassKeys) {
            if (!otherSet.has(k)) return false;
          }
        } else {
          if (otherMergeCount > 1) return false;
        }

        if(!useJoint) {
          return o.teacher !== a && sameClassAndCourse(me,o);
        }
        return !namesSelf.includes(o.teacher) && sameClassAndCourse(me,o);
      });

      // --- 1対1 ---
      const c1raw = poolBase
        .filter(o=>{
          const selfFree = !useJoint
            ? !teacherHasSlot(a, o.day, o.period)
            : !teacherHasSlotMany(namesSelf, o.day, o.period);

          const oppAllTeachers = getAllTeachersForLesson(o);
          const otherFree = !oppAllTeachers.some(t => teacherHasSlot(t, myDay, myPeriod));

          return selfFree && otherFree;
        })
        .map(o=>{
          const oppHasEventAtMy = hasAnyEvent(o.teacher, myDay, myPeriod);

          const aHasEventAtOpp  = hasAnyEvent(a, o.day, o.period);
          const bHasEventAtOpp  = b ? hasAnyEvent(b, o.day, o.period) : false;
          const cHasEventAtOpp  = c ? hasAnyEvent(c, o.day, o.period) : false;

          const trainingDetailsSet = new Set();

          const d1 = getTrainingDetailLabel(o.teacher, myDay, myPeriod);
          if(d1) trainingDetailsSet.add(d1);

          const d2 = getTrainingDetailLabel(a, o.day, o.period);
          if(d2) trainingDetailsSet.add(d2);
          if(b){
            const d3 = getTrainingDetailLabel(b, o.day, o.period);
            if(d3) trainingDetailsSet.add(d3);
          }
          if(c){
            const d4 = getTrainingDetailLabel(c, o.day, o.period);
            if(d4) trainingDetailsSet.add(d4);
          }

          const trainingDetails = Array.from(trainingDetailsSet);

          const selfTraining  = aHasEventAtOpp;
          const otherTraining = oppHasEventAtMy || bHasEventAtOpp || cHasEventAtOpp;
          const parttime      = isParttimeTeacher(o.teacher);
          const trainingFlag  = selfTraining || otherTraining;

          return {
            other          : o,
            trainingDetails,
            selfTraining,
            otherTraining,
            parttime,
            trainingFlag,
            priority       : getPriority(o, me)
          };
        });

      const grouped = new Map();
      c1raw.forEach(cand=>{
        const key = signatureKey(cand.other);
        if(!grouped.has(key)) grouped.set(key, []);
        grouped.get(key).push(cand);
      });

      const c1 = [];
      grouped.forEach(list=>{
        const repLesson   = list[0].other;
        const teachersAll = getAllTeachersForLesson(repLesson);
        const canonical   = teachersAll[0] || repLesson.teacher;
        const base        = list.find(c=>c.other.teacher===canonical) || list[0];

        const trainingDetailsSet = new Set(list.flatMap(c=>c.trainingDetails));
        teachersAll.forEach(t=>{
          const label = getTrainingDetailLabel(t, me.day, me.period);
          if(label) trainingDetailsSet.add(label);
        });

        const trainingDetails = Array.from(trainingDetailsSet);
        const selfTraining    = list.some(c=>c.selfTraining);

        let otherTraining = list.some(c=>c.otherTraining);
        if(!otherTraining){
          for(const t of teachersAll){
            if(hasAnyEvent(t, me.day, me.period)){
              otherTraining = true;
              break;
            }
          }
        }

        let parttime = list.some(c=>c.parttime);
        if(!parttime){
          for(const t of teachersAll){
            if(isParttimeTeacher(t)){
              parttime = true;
              break;
            }
          }
        }

        const trainingFlag = selfTraining || otherTraining;
        const priority     = Math.max(...list.map(c=>c.priority));
        const otherLesson  = { ...base.other, teacher: canonical };
        const isJoint      = isJointLessonForTeacher(repLesson);

        c1.push({
          other        : otherLesson,
          teachersAll,
          trainingDetails,
          selfTraining,
          otherTraining,
          parttime,
          trainingFlag,
          joint        : isJoint,
          priority
        });
      });

      function oneToOneCategory(cand){
        if(cand.parttime) return 3;
        if(!cand.trainingFlag){
          return cand.joint ? 1 : 0;
        }
        return 2;
      }

      c1.sort((x,y)=>{
        const cx = oneToOneCategory(x);
        const cy = oneToOneCategory(y);
        if (cx !== cy) return cx - cy;

        const dx = DAY_ORDER[x.other.day] || 99;
        const dy = DAY_ORDER[y.other.day] || 99;
        if (dx !== dy) return dx - dy;

        if (x.other.period !== y.other.period) return x.other.period - y.other.period;

        const nameX = x.teachersAll && x.teachersAll.length ? x.teachersAll.join('・') : x.other.teacher;
        const nameY = y.teachersAll && y.teachersAll.length ? y.teachersAll.join('・') : y.other.teacher;
        return collatorJA.compare(nameX, nameY);
      });

      const h2a = document.createElement('h2');
      h2a.textContent = useJoint ? "■ A⇔B 候補（合同）" : "■ A⇔B 候補";
      results1to1Div.appendChild(h2a);

      if(!c1.length){
        results1to1Div.insertAdjacentHTML("beforeend","<p class='muted'>候補はありません</p>");
      }else{
        const tbl = document.createElement('table');
        tbl.innerHTML = `<thead><tr>
          <th>交換相手</th><th>交換先授業</th><th>あなたの授業</th>
          <th class="nowrap">予定</th><th class="nowrap">非常勤</th>
        </tr></thead>`;
        const tb = document.createElement('tbody');
        c1.forEach(cand=>{
          const o  = cand.other;
          const tr = document.createElement('tr');

          const myTitle = renderMyLessonText(me);
          const teacherLabel = cand.teachersAll && cand.teachersAll.length
            ? cand.teachersAll.join('・')
            : o.teacher;
          const trainingText = cand.trainingDetails.length
            ? cand.trainingDetails.join("<br>")
            : "";

          tr.innerHTML = `<td>${teacherLabel}</td>
            <td>${renderLessonTextForResult(o)}</td>
            <td>${myTitle}</td>
            <td style="text-align:center;">${trainingText}</td>
            <td style="text-align:center;">${cand.parttime?"〇":""}</td>`;

          if(cand.parttime){
            tr.classList.add("parttime-row");
          } else if(cand.selfTraining || cand.otherTraining){
            tr.classList.add("training-conflict");
          }

          tb.appendChild(tr);
        });
        tbl.appendChild(tb);
        results1to1Div.appendChild(tbl);
      }

      // --- 二段階交換（A⇔B・A⇔C候補用） ---
      const chainCandidates = [];
      const normal1to1Count = c1.filter(c => !c.trainingFlag && !c.parttime).length;

      if (!useJoint && a && normal1to1Count <= 3) {
        const teacherA   = a;
        const teachersMe = getAllTeachersForLesson(me);

        if (teachersMe.length === 1 && teachersMe[0] === teacherA) {
          for (let i = 0; i < poolBase.length; i++) {
            const B1 = poolBase[i];
            if (B1.teacher === teacherA) continue;

            const teachersB = getAllTeachersForLesson(B1);
            if (teachersB.length !== 1) continue;
            const teacherB = teachersB[0];

            const directSelfFree  = !teacherHasSlot(teacherA, B1.day, B1.period);
            const directOtherFree = !teacherHasSlot(teacherB, myDay, myPeriod);
            if (directSelfFree && directOtherFree) continue;

            const blockers = [];
            if (!directSelfFree) {
              lessons.forEach(l => {
                if (l.teacher === teacherA &&
                    l.day === B1.day &&
                    l.period === B1.period) {
                  blockers.push(l);
                }
              });
            }
            if (!directOtherFree) {
              lessons.forEach(l => {
                if (l.teacher === teacherB &&
                    l.day === myDay &&
                    l.period === myPeriod) {
                  blockers.push(l);
                }
              });
            }
            if (!blockers.length) continue;

            for (let bIdx = 0; bIdx < blockers.length; bIdx++) {
              const blockLesson  = blockers[bIdx];
              const teacherBlock = blockLesson.teacher;

              const partners = lessons.filter(o => {
                if (o === blockLesson) return false;
                if (o.teacher === teacherBlock) return false;
                if (!sameClassAndCourse(blockLesson, o)) return false;
                if (o.day === blockLesson.day && o.period === blockLesson.period) return false;
                return true;
              });

              for (let k = 0; k < partners.length; k++) {
                const partner       = partners[k];
                const tPartnerArr   = getAllTeachersForLesson(partner);
                if (tPartnerArr.length !== 1) continue;
                const teacherPartner = tPartnerArr[0];

                const ops = [];

                ops.push({
                  teacher   : teacherBlock,
                  dayFrom   : blockLesson.day,
                  periodFrom: blockLesson.period,
                  dayTo     : partner.day,
                  periodTo  : partner.period
                });
                ops.push({
                  teacher   : teacherPartner,
                  dayFrom   : partner.day,
                  periodFrom: partner.period,
                  dayTo     : blockLesson.day,
                  periodTo  : blockLesson.period
                });
                ops.push({
                  teacher   : teacherA,
                  dayFrom   : me.day,
                  periodFrom: myPeriod,
                  dayTo     : B1.day,
                  periodTo  : B1.period
                });
                ops.push({
                  teacher   : teacherB,
                  dayFrom   : B1.day,
                  periodFrom: B1.period,
                  dayTo     : me.day,
                  periodTo  : myPeriod
                });

                let invalidChain = false;

                const chainTeachers = [teacherA, teacherB, teacherBlock, teacherPartner];
                for (const tName of chainTeachers) {
                  if (isParttimeTeacher(tName)) {
                    invalidChain = true;
                    break;
                  }
                }

                if (!invalidChain) {
                  for (const op of ops) {
                    if (hasAnyEvent(op.teacher, op.dayFrom, op.periodFrom) ||
                        hasAnyEvent(op.teacher, op.dayTo,   op.periodTo)) {
                      invalidChain = true;
                      break;
                    }
                  }
                }

                if (invalidChain) continue;

                if (validateOperations(ops, scheduleState)) {
                  chainCandidates.push({
                    mainB        : B1,
                    blockLesson,
                    partner,
                    teacherA,
                    teacherB,
                    teacherBlock,
                    teacherPartner
                  });
                }
              }
            }
          }
        }
      }

      // --- 三者ローテ ---
      const h2b = document.createElement('h2');
      h2b.textContent = "■ A⇔B⇔C候補";
      results3wayDiv.appendChild(h2b);

      const note = document.createElement('p');
      note.className = 'muted';
      let filteredOut = 0;
      const c3        = [];
      const namesSelfFor3 = namesSelf.length ? namesSelf : [a];
      const baseState = scheduleState;

      for(let i=0;i<poolBase.length;i++){
        const lB = poolBase[i];
        for(let j=i+1;j<poolBase.length;j++){
          const lC = poolBase[j];
          if(lB.teacher === lC.teacher) continue;
          if(lB.day===lC.day && lB.period===lC.period) continue;

          const teachersA = getAllTeachersForLesson(me);
          const teachersB = getAllTeachersForLesson(lB);
          const teachersC = getAllTeachersForLesson(lC);

          const groupA = Array.from(new Set([...namesSelfFor3, ...teachersA]));
          const groupB = teachersB.slice();
          const groupC = teachersC.slice();

          const allTeachersTriple = Array.from(new Set([
            ...groupA, ...groupB, ...groupC
          ]));

          const hasParttimeTriple = allTeachersTriple.some(t => isParttimeTeacher(t));
          const hasTrainingAt = (day, period) =>
            allTeachersTriple.some(t => hasAnyEvent(t, day, period));

          const trainAtA = hasTrainingAt(myDay, myPeriod);
          const trainAtB = hasTrainingAt(lB.day, lB.period);
          const trainAtC = hasTrainingAt(lC.day, lC.period);

          if (hasParttimeTriple || trainAtA || trainAtB || trainAtC) {
            filteredOut++;
            continue;
          }

          const patterns = [1,2];
          let anyValid   = false;

          patterns.forEach(pId=>{
            const rotateOps = buildRotate3OperationsPattern(me, lB, lC, groupA, groupB, groupC, pId);
            const ok = validateOperations(rotateOps, baseState);
            if(!ok){
              filteredOut++;
              return;
            }
            anyValid = true;
            const priority = getPriority(lB,me) + getPriority(lC,me);
            c3.push({lA:me,lB,lC,priority,patternId:pId});
          });

          if (!anyValid) continue;
        }
      }

      const grouped3 = new Map();
      c3.forEach(item=>{
        const keyB = signatureKey(item.lB);
        const keyC = signatureKey(item.lC);
        const key  = `${keyB}||${keyC}||${item.patternId}`;
        if(!grouped3.has(key)) grouped3.set(key, []);
        grouped3.get(key).push(item);
      });

      const c3display = [];
      grouped3.forEach(list=>{
        const rep      = list[0];
        const priority = Math.max(...list.map(it=>it.priority));
        c3display.push({ lA:rep.lA, lB:rep.lB, lC:rep.lC, priority, patternId:rep.patternId });
      });

      note.textContent = `※研修・会議・非常勤などの条件不一致の組み合わせは除外（${filteredOut}件）`;
      results3wayDiv.appendChild(note);

      if(!c3display.length){
        results3wayDiv.insertAdjacentHTML("beforeend","<p class='muted'>候補はありません</p>");
      }else{
        c3display.sort((aItem,bItem)=>bItem.priority-aItem.priority);
        const tbl = document.createElement('table');
        tbl.innerHTML = `<thead><tr>
          <th>担当者</th><th>該当する授業</th>
          <th>担当者</th><th>該当する授業</th>
          <th>移動案</th>
        </tr></thead>`;
        const tb = document.createElement('tbody');
        c3display.forEach(cand=>{
          const A3 = cand.lA, B3 = cand.lB, C3 = cand.lC;

          const teachersB = getAllTeachersForLesson(B3);
          const teachersC = getAllTeachersForLesson(C3);
          const labelB    = teachersB.length ? teachersB.join('・') : B3.teacher;
          const labelC    = teachersC.length ? teachersC.join('・') : C3.teacher;
          const selfLabel = namesSelfFor3.join('＋') || a;

          let moveBody = "";
          if (cand.patternId === 2) {
            moveBody =
              `${selfLabel}：${formatSlot(A3.day,A3.period)} → ${formatSlot(C3.day,C3.period)}<br>`+
              `${labelC}：${formatSlot(C3.day,C3.period)} → ${formatSlot(B3.day,B3.period)}<br>`+
              `${labelB}：${formatSlot(B3.day,B3.period)} → ${formatSlot(A3.day,A3.period)}`;
          } else {
            moveBody =
              `${selfLabel}：${formatSlot(A3.day,A3.period)} → ${formatSlot(B3.day,B3.period)}<br>`+
              `${labelB}：${formatSlot(B3.day,B3.period)} → ${formatSlot(C3.day,C3.period)}<br>`+
              `${labelC}：${formatSlot(C3.day,C3.period)} → ${formatSlot(A3.day,A3.period)}`;
          }

          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${labelB}</td>
            <td>${renderLessonTextForResult(B3)}</td>
            <td>${labelC}</td>
            <td>${renderLessonTextForResult(C3)}</td>
            <td>${moveBody}</td>`;
          tb.appendChild(tr);
        });
        tbl.appendChild(tb);
        results3wayDiv.appendChild(tbl);
      }

      // --- A⇔B・A⇔C候補 ---
      const h2chain = document.createElement('h2');
      h2chain.textContent = "■ A⇔B・A⇔C候補";
      results3wayDiv.appendChild(h2chain);

      if (chainCandidates.length) {
        const tblChain = document.createElement('table');
        tblChain.innerHTML = `<thead><tr>
          <th>交換１</th>
          <th>交換２</th>
          <th>移動案</th>
        </tr></thead>`;
        const tbChain = document.createElement('tbody');

        chainCandidates.forEach(cand=>{
          const { mainB, blockLesson, partner,
                  teacherA, teacherB,
                  teacherBlock, teacherPartner } = cand;

          const row       = document.createElement('tr');
          const mainLabel =
            `${teacherA}：${renderLessonTextForResult(me)} ⇔ ` +
            `${teacherB}：${renderLessonTextForResult(mainB)}`;

          const subLabel =
            `${teacherBlock}：${renderLessonTextForResult(blockLesson)} ⇔ ` +
            `${teacherPartner}：${renderLessonTextForResult(partner)}`;

          const moveDesc =
            `${teacherBlock}：${formatSlot(blockLesson.day, blockLesson.period)} → ${formatSlot(partner.day, partner.period)}<br>`+
            `${teacherPartner}：${formatSlot(partner.day, partner.period)} → ${formatSlot(blockLesson.day, blockLesson.period)}<br>`+
            `${teacherA}：${formatSlot(me.day, me.period)} → ${formatSlot(mainB.day, mainB.period)}<br>`+
            `${teacherB}：${formatSlot(mainB.day, mainB.period)} → ${formatSlot(me.day, me.period)}`;

          row.innerHTML = `
            <td>${mainLabel}</td>
            <td>${subLabel}</td>
            <td>${moveDesc}</td>
          `;
          tbChain.appendChild(row);
        });

        tblChain.appendChild(tbChain);
        results3wayDiv.appendChild(tblChain);
      } else {
        const pCond = document.createElement('p');
        pCond.className = 'muted';
        pCond.textContent =
          "※表示条件: 単独授業かつ、研修・会議・非常勤に該当しないA⇔B候補が3件以下のときに候補を検索";
        results3wayDiv.appendChild(pCond);
      }

      // --- 文理特別ローテ ---
      const bunriCandidates = [];
      if (!useJoint && a && normal1to1Count <= 3 && isBunriUnitForLesson(me)) {
        const grade = me.grade;
        const cls   = me.class;

        const myBunriUnit  = getUnitLessons(me);
        const myBunriClass = new Set(myBunriUnit.map(x => `${x.grade}-${x.class}`));

        const bunLessons = lessons.filter(x =>
          x.school === me.school &&
          x.grade === grade &&
          x.class === cls &&
          x.course === "文"
        );
        const riLessons = lessons.filter(x =>
          x.school === me.school &&
          x.grade === grade &&
          x.class === cls &&
          x.course === "理"
        );

        const pairMap = new Map();
        bunLessons.forEach(lBun=>{
          riLessons.forEach(lRi=>{
            if (lBun.day !== lRi.day || lBun.period !== lRi.period) return;
            if (lBun.teacher === a && lRi.teacher === a) return;

            const bunUnit = getUnitLessons(lBun);
            const riUnit  = getUnitLessons(lRi);
            const allKeys = new Set();
            bunUnit.forEach(x => allKeys.add(`${x.grade}-${x.class}`));
            riUnit.forEach(x => allKeys.add(`${x.grade}-${x.class}`));
            let hasExtra = false;
            for (const key of allKeys) {
              if (!myBunriClass.has(key)) {
                hasExtra = true;
                break;
              }
            }
            if (hasExtra) return;

            const key = `${lBun.day}|${lBun.period}|${lBun.teacher}|${lRi.teacher}`;
            if (pairMap.has(key)) return;

            const ops = [
              { teacher: a,           dayFrom: me.day,      periodFrom: me.period,      dayTo: lBun.day, periodTo: lBun.period },
              { teacher: lBun.teacher,dayFrom: lBun.day,    periodFrom: lBun.period,    dayTo: me.day,   periodTo: me.period },
              { teacher: lRi.teacher, dayFrom: lRi.day,     periodFrom: lRi.period,     dayTo: me.day,   periodTo: me.period }
            ];

            if (!validateOperations(ops, scheduleState, { allowTraining: true })) return;

            pairMap.set(key, {
              bun: lBun,
              ri : lRi
            });
          });
        });

        bunriCandidates.push(...pairMap.values());
      }

      if (bunriCandidates.length) {
        const h2spec = document.createElement('h2');
        h2spec.textContent = "■ A⇔B＋C候補";
        results3wayDiv.appendChild(h2spec);

        const tblSpec = document.createElement('table');
        tblSpec.innerHTML = `<thead><tr>
          <th>A（文理）</th>
          <th>文側</th>
          <th>理側</th>
          <th>移動案</th>
          <th>予定（注意）</th>
        </tr></thead>`;
        const tbSpec = document.createElement('tbody');

        bunriCandidates.forEach(cand=>{
          const bun = cand.bun;
          const ri  = cand.ri;

          const tr = document.createElement('tr');

          const labelA   = `${a}：${renderLessonTextForResult(me)}`;
          const labelBun = `${bun.teacher}：${renderLessonTextForResult(bun)}`;
          const labelRi  = `${ri.teacher}：${renderLessonTextForResult(ri)}`;

          const moveDesc =
            `${a}：${formatSlot(me.day, me.period)} → ${formatSlot(bun.day, bun.period)}<br>`+
            `${bun.teacher}：${formatSlot(bun.day, bun.period)} → ${formatSlot(me.day, me.period)}<br>`+
            `${ri.teacher}：${formatSlot(ri.day, ri.period)} → ${formatSlot(me.day, me.period)}`;

          const warnSet = new Set();
          warnSet.add(getTrainingDetailLabel(a, me.day, me.period));
          warnSet.add(getTrainingDetailLabel(a, bun.day, bun.period));
          warnSet.add(getTrainingDetailLabel(bun.teacher, me.day, me.period));
          warnSet.add(getTrainingDetailLabel(bun.teacher, bun.day, bun.period));
          warnSet.add(getTrainingDetailLabel(ri.teacher, me.day, me.period));
          warnSet.add(getTrainingDetailLabel(ri.teacher, ri.day, ri.period));

          const warnings = Array.from(warnSet)
            .filter(s => s && s.trim())
            .join("<br>");

          tr.innerHTML = `
            <td>${labelA}</td>
            <td>${labelBun}</td>
            <td>${labelRi}</td>
            <td>${moveDesc}</td>
            <td class="training-conflict">${warnings || ""}</td>
          `;
          tbSpec.appendChild(tr);
        });

        tblSpec.appendChild(tbSpec);
        results3wayDiv.appendChild(tblSpec);
      }
    });

    // ===== 起動時：埋め込みCSV読み込み =====
    window.addEventListener('DOMContentLoaded', ()=>{
      if(EMBEDDED_TRAININGS_CSV.trim())  loadTrainingsFromText(EMBEDDED_TRAININGS_CSV);
      if(EMBEDDED_LESSONS_HS_CSV.trim()) loadLessonsFromTextHS(EMBEDDED_LESSONS_HS_CSV);
      if(EMBEDDED_LESSONS_JH_CSV.trim()) loadLessonsFromTextJH(EMBEDDED_LESSONS_JH_CSV);
    });
  </script>
</body>
</html>
